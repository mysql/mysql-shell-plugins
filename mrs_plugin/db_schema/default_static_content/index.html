<!--
 * Copyright (c) 2022, 2024, Oracle and/or its affiliates.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License, version 2.0,
 * as published by the Free Software Foundation.
 *
 * This program is designed to work with certain software (including
 * but not limited to OpenSSL) that is licensed under separate terms, as
 * designated in a particular file or component or in included license
 * documentation.  The authors of MySQL hereby grant you an additional
 * permission to link the program and your derivative works with the
 * separately licensed software that they have either included with
 * the program or referenced in the documentation.
 *
 * This program is distributed in the hope that it will be useful,  but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
 * the GNU General Public License, version 2.0, for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 -->
<!DOCTYPE html>
<html>

<head>
    <title>MySQL REST Service</title>
    <link rel="icon" type="image/svg+xml" href="./favicon.svg">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <style>
        :root {
            --body-background: hsl(240, 5%, 91%);
            --body-text-color: hsl(240, 5%, 12%);
            --icon-color: hsl(200, 65%, 40%);
            --textLink-foreground: hsl(200, 65%, 34%);
            --main-background-color: #fff;
            --secondary-background-color: #fff;
            --toolbar-background-color: #f5f5f7;
            --toolbar-secondary-background-color: #f8f8f8;
            --list-background-color: #F2F2F7;
            --list-item-background-color: #fff;
            --list-item-selected-background-color: hsl(240, 8%, 88%);
            --list-item-selected-focus-background-color: hsl(200, 65%, 86%);
            --button-background-color: #6E6D70;
            --primary-text-color: #333333;
            --secondary-text-color: #ADADAD;
            --title-text-color: #222;
            --list-item-color: #000;
            --list-item-secondary-color: #666;
            --button-text-color: #DFDEDF;
            --splitter-color: #D4D4D4;
            --icon-color: hsl(200, 65%, 40%);
            --focus-color: hsl(200, 65%, 70%);
            --error-color: hsl(0, 100%, 70%);
            --error-text-color: #500
        }

        @media (prefers-color-scheme:dark) {
            :root {
                --body-background: hsl(0, 0%, 17%);
                --body-text-color: hsl(0, 0%, 75%);
                --textLink-foreground: hsl(200, 65%, 54%);
                --main-background-color: #0d0d0d;
                --secondary-background-color: #181A1B;
                --toolbar-background-color: #1D2021;
                --toolbar-secondary-background-color: #181A1B;
                --list-background-color: #1E2022;
                --list-item-background-color: #181A1B;
                --list-item-selected-background-color: hsl(210, 7%, 20%);
                --list-item-selected-focus-background-color: hsl(200, 65%, 20%);
                --button-background-color: #666;
                --primary-text-color: #c4c4c4;
                --secondary-text-color: #595959;
                --title-text-color: #e5e5e7;
                --list-item-color: #E8E6E3;
                --list-item-secondary-color: #666;
                --splitter-color: #3A3436;
                --icon-color: hsl(200, 65%, 40%);
                --focus-color: hsl(200, 65%, 30%);
                --error-color: hsl(0, 100%, 20%);
                --error-text-color: #e00
            }
        }

        body,
        html {
            width: 100%;
            height: 100%
        }

        * {
            margin: 0;
            padding: 0
        }

        body {
            overflow: hidden;
            background-color: var(--body-background);
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            font-size: 12px;
            color: var(--body-text-color)
        }

        h2 {
            margin: 20px 0;
            font-weight: 100;
            font-size: 33px
        }

        p {
            line-height: 19px;
            font-weight: 200;
            font-size: 15px
        }

        a {
            color: var(--textLink-foreground);
            text-decoration: none;
            font-weight: 500;
            padding: 0 20px;
            font-size: 15px
        }

        #root {
            display: flex;
            width: 100%;
            height: 100%;
            flex-direction: column;
            align-items: center;
            justify-content: center
        }

        .welcomeLogo {
            margin-top: 20px;
            width: 160px;
            height: 160px;
            min-height: 160px;
            background-color: var(--icon-color);
            -webkit-mask-image: url(sakila.svg);
            mask-image: url(sakila.svg)
        }

        .welcomeText {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center
        }

        .welcomeText p {
            text-align: center
        }

        .welcomeLinks {
            padding: 30px 0
        }

        .welcomeSpacer {
            height: 80px
        }

        .footer {
            position: absolute;
            bottom: 0;
            line-height: 12pt;
            font-weight: 200;
            font-size: 10px;
            margin: 5px 0
        }

        .mrsLogin {
            display: flex;
            flex-direction: column;
            padding-top: 20px;
            padding-bottom: 20px;
            gap: 12px;
            align-items: center
        }

        .mrsLogin p {
            font-size: 20px;
            font-weight: 400
        }

        .mrsLoginFields {
            display: flex;
            flex-direction: column
        }

        .mrsLoginFields input[type=password],
        .mrsLoginFields input[type=text] {
            border: none;
            outline: 0;
            background-color: transparent;
            color: var(--primary-text-color);
            font-size: 17px;
            font-weight: 300;
            width: 250px
        }

        .mrsLoginField {
            display: flex;
            flex-direction: row;
            border: 1px solid var(--secondary-text-color);
            padding: 8px 8px 8px 16px
        }

        .mrsLoginField:first-of-type {
            border-top-left-radius: 5px;
            border-top-right-radius: 5px
        }

        .mrsLoginField:last-of-type:not(:only-of-type) {
            border-top: 0
        }

        .mrsLoginField:last-of-type {
            border-bottom-left-radius: 5px;
            border-bottom-right-radius: 5px;
            margin-bottom: 16px
        }

        .mrsLoginField input {
            height: 26px
        }

        .mrsLoginBtnNext {
            border: 1px solid var(--secondary-text-color);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            margin-left: 12px;
            padding-right: 0
        }

        .mrsLoginBtnNext.active {
            border: 1px solid var(--primary-text-color)
        }

        .mrsLoginBtnNext.loading {
            border: none;
            width: 26px
        }

        .mrsLoginBtnNext::after {
            content: "";
            position: relative;
            border: solid var(--secondary-text-color);
            border-width: 0 3px 3px 0;
            display: inline-block;
            padding: 3px;
            transform: rotate(-45deg);
            -webkit-transform: rotate(-45deg);
            margin-left: 6px;
            margin-top: 7px
        }

        .mrsLoginBtnNext.active::after {
            content: "";
            position: relative;
            border: solid var(--primary-text-color);
            border-width: 0 3px 3px 0;
            display: inline-block;
            padding: 3px;
            transform: rotate(-45deg);
            -webkit-transform: rotate(-45deg);
            margin-left: 6px;
            margin-top: 7px
        }

        .mrsLoginBtnNext.loading::after {
            content: " ";
            display: block;
            width: 17px;
            height: 17px;
            margin-left: -3px;
            margin-top: -2px;
            border-radius: 50%;
            border: 4px solid var(--primary-text-color);
            border-color: var(--primary-text-color) transparent var(--primary-text-color) transparent;
            animation: mrsLoaderKeyframes 1.2s linear infinite
        }

        @keyframes mrsLoaderKeyframes {
            0% {
                transform: rotate(0)
            }

            100% {
                transform: rotate(360deg)
            }
        }

        .mrsLoginError {
            background-color: var(--error-color);
            box-shadow: rgb(0 0 0 / 10%) 0 5px 10px 2px;
            width: 220px;
            padding: 8px 20px 8px 20px;
            border: 1px solid var(--error-text-color);
            border-radius: 6px;
            overflow-wrap: break-word;
        }

        .mrsLoginError p {
            color: var(--error-text-color);
            font-size: 14px;
            text-align: center
        }

        .mrsLoginError:before {
            width: 15px;
            height: 15px;
            background-color: var(--error-color);
            content: "";
            position: absolute;
            left: 50%;
            margin-top: -16px;
            margin-left: -15px;
            transform: rotate(135deg) skewX(5deg) skewY(5deg);
            -webkit-transform: rotate(135deg) skewX(5deg) skewY(5deg);
            border-left: 1px solid var(--error-text-color);
            border-bottom: 1px solid var(--error-text-color)
        }

        .mrsLoginSeparator {
            background: linear-gradient(to right, rgba(200, 200, 200, 0), #c8c8c8, #c8c8c8, rgba(200, 200, 200, 0));
            width: 400px;
            height: 1px;
            margin-top: 20px
        }
    </style>
</head>

<body>
    <div id="root"></div>
    <script type="module">
        import { h, render, Component, createRef, html } from './standalone-preact.js'

        class MrsBaseSession {
            loginState = {};

            constructor(
                serviceUrl,
                authPath,
                defaultTimeout = 8000) {
                this.serviceUrl = serviceUrl;
                this.authPath = authPath ?? "/authentication";
                this.defaultTimeout = defaultTimeout;
            }

            /**
             * A small wrapper around fetch() that uses the active JWT accessToken to the MRS and throws
             * an exception if the response was not OK
             *
             * @param input The RequestInfo, either a URL string or a JSON object with named parameters
             * @param errorMsg The error message to include in the exception if the fetch is not successful
             * @param method The HTTP method to use with GET being the default
             * @param body The request body as object
             * @param autoResponseCheck Set to false if the error checking should not be performed
             * @param timeout The timeout for this fetch call. If not specified, the default timeout of the session is used.
             *
             * @returns The response object
             */
            doFetch = async (input, errorMsg,
                method, body, autoResponseCheck,
                timeout) => {
                // Check if parameters are passed as named parameters and if so, assign them
                if (typeof input === "object" && input !== null) {
                    errorMsg = input?.errorMsg ?? "Failed to fetch data.";
                    method = input?.method ?? "GET";
                    body = input?.body;
                    timeout = input?.timeout;
                    input = input?.input;
                } else {
                    errorMsg = errorMsg ?? "Failed to fetch data.";
                    method = method ?? "GET";
                }

                const controller = new AbortController();
                const timeoutTimer = setTimeout(() => { controller.abort(); }, timeout ?? this.defaultTimeout);
                let response;

                try {
                    response = await fetch(`${this.serviceUrl ?? ""}${input}`, {
                        method,
                        // eslint-disable-next-line @typescript-eslint/naming-convention
                        headers: (this.accessToken !== undefined)
                            ? { Authorization: "Bearer " + this.accessToken }
                            : undefined,
                        body: (body !== undefined) ? JSON.stringify(body) : undefined,
                        signal: controller.signal,
                    });
                } catch (e) {
                    throw new Error(`${errorMsg}\n\nPlease check if MySQL Router is running and the REST endpoint `
                        + `${this.serviceUrl ?? ""}${input} does exist.\n\n`
                        + `${(e instanceof Error) ? e.message : String(e)}`);
                } finally {
                    clearTimeout(timeoutTimer);
                }

                if (!response.ok && autoResponseCheck) {
                    // Check if the current session has expired
                    if (response.status === 401) {
                        /* this.setState({ restarting: true });
                        window.alert("Your current session expired. You will be logged in again.");

                        void this.startLogin(authApp); */
                        throw new Error(`Not authenticated. Please authenticate first before accessing the ` +
                            `path ${this.serviceUrl ?? ""}${input}.`);
                    }

                    let errorInfo;
                    try {
                        errorInfo = await response.json();
                    } catch (e) {
                        throw new Error(`${response.status}. ${errorMsg} (${response.statusText})`);
                    }
                    // If there is a message, throw with that message
                    if (typeof errorInfo.message === "string") {
                        throw new Error(String(errorInfo.message));
                    } else {
                        throw new Error(`${response.status}. ${errorMsg} (${response.statusText})` +
                            `${(errorInfo !== undefined) ? ("\n\n" + JSON.stringify(errorInfo, null, 4) + "\n") : ""}`);
                    }
                }

                return response;
            };

            getAuthApps = async () => {
                const response = await this.doFetch({
                    input: `${this.authPath}/authApps`,
                    timeout: 3000,
                    errorMsg: "Failed to fetch Authentication Apps.",
                });

                if (response.ok) {
                    const result = await response.json();

                    return result;
                } else {
                    let errorInfo = null;
                    try {
                        errorInfo = await response.json();
                    } catch (e) {
                        // Ignore the exception
                    }
                    const errorDesc = "Failed to fetch Authentication Apps.\n\n" +
                        "Please ensure MySQL Router is running and the REST endpoint " +
                        `${String(this.serviceUrl)}${this.authPath}/authApps is accessible. `;

                    throw new Error(errorDesc + `(${response.status}:${response.statusText})` +
                        `${(errorInfo !== undefined && errorInfo !== null)
                            ? ("\n\n" + JSON.stringify(errorInfo, null, 4) + "\n")
                            : ""}`);
                }
            };

            /**
             * Gets the authentication status of the current session as defined by the accessToken
             *
             * @returns The response object with {"status":"authorized", "user": {...}} or {"status":"unauthorized"}
             */
            getAuthenticationStatus = async () => {
                try {
                    return (await (await this.doFetch(
                        { input: `/authentication/status`, errorMsg: "Failed to authenticate." })).json());
                } catch (e) {
                    return { status: "unauthorized" };
                }
            };

            verifyUserName = async (authApp, userName) => {
                this.authApp = authApp;

                const nonce = this.hex(crypto.getRandomValues(new Uint8Array(10)));

                const challenge = await (await this.doFetch({
                    input: `${this.authPath}/login?app=${authApp}`,
                    method: "POST",
                    body: {
                        user: userName,
                        nonce,
                    },
                })).json();

                // Convert the salt to and Uint8Array
                challenge.salt = new Uint8Array(challenge.salt);

                this.loginState = {
                    clientFirst: `n=${userName},r=${nonce}`,
                    clientFinal: `r=${challenge.nonce}`,
                    serverFirst: this.buildServerFirst(challenge),
                    challenge,
                    loginError: undefined,
                };
            };

            verifyPassword = async (password) => {
                const { challenge, clientFirst, serverFirst, clientFinal } = this.loginState;

                if (password !== undefined && password !== "" && this.authApp !== undefined &&
                    clientFirst !== undefined && serverFirst !== undefined && challenge !== undefined &&
                    clientFinal !== undefined) {
                    const te = new TextEncoder();
                    const authMessage = `${clientFirst},${serverFirst},${clientFinal}`;
                    const clientProof = Array.from(await this.calculateClientProof(
                        password, challenge.salt, challenge.iterations, te.encode(authMessage)));

                    try {
                        const response = await this.doFetch({
                            input: `${this.authPath}/login?app=${this.authApp}&sessionType=bearer` +
                                (challenge.session !== undefined ? "&session=" + challenge.session : ""),
                            method: "POST",
                            body: {
                                clientProof,
                                nonce: challenge.nonce,
                                state: "response",
                            },
                        }, undefined, undefined, undefined, false);

                        if (!response.ok) {
                            this.accessToken = undefined;

                            return {
                                authApp: this.authApp,
                                errorCode: response.status,
                                errorMessage: (response.status === 401)
                                    ? "The sign in failed. Please check your username and password."
                                    : `The sign in failed. Error code: ${String(response.status)}`,
                            };
                        } else {
                            const result = await response.json();

                            this.accessToken = String(result.accessToken);

                            return {
                                authApp: this.authApp,
                                jwt: this.accessToken,
                            };
                        }
                    } catch (e) {
                        return {
                            authApp: this.authApp,
                            errorCode: 2,
                            errorMessage: `The sign in failed. Server Error: ${String(e)}`,
                        };
                    }
                } else {
                    return {
                        authApp: this.authApp,
                        errorCode: 1,
                        errorMessage: `No password given.`,
                    };
                }
            };

            hex = (arrayBuffer) => {
                return Array.from(new Uint8Array(arrayBuffer))
                    .map((n) => { return n.toString(16).padStart(2, "0"); })
                    .join("");
            };

            buildServerFirst = (challenge) => {
                const b64Salt = window.btoa(String.fromCharCode.apply(null, Array.from(challenge.salt)));

                return `r=${challenge.nonce},s=${b64Salt},i=${String(challenge.iterations)}`;
            };

            calculatePbkdf2 = async (password, salt,
                iterations) => {
                const ck1 = await crypto.subtle.importKey(
                    "raw", password, { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]);
                const result = new Uint8Array(await crypto.subtle.deriveBits(
                    { name: "PBKDF2", hash: "SHA-256", salt, iterations }, ck1, 256));

                return result;
            };

            calculateSha256 = async (data) => {
                return new Uint8Array(await crypto.subtle.digest("SHA-256", data));
            };

            calculateHmac = async (secret, data) => {
                const key = await window.crypto.subtle.importKey(
                    "raw", secret, { name: "HMAC", hash: { name: "SHA-256" } }, true, ["sign", "verify"]);
                const signature = await window.crypto.subtle.sign("HMAC", key, data);

                return new Uint8Array(signature);
            };

            calculateXor = (a1, a2) => {
                const l1 = a1.length;
                const l2 = a2.length;
                // cSpell:ignore amax
                let amax;
                let amin;
                let loop;

                if (l1 > l2) {
                    amax = new Uint8Array(a1);
                    amin = a2;
                    loop = l2;
                } else {
                    amax = new Uint8Array(a2);
                    amin = a1;
                    loop = l1;
                }

                for (let i = 0; i < loop; ++i) {
                    amax[i] ^= amin[i];
                }

                return amax;
            };

            calculateClientProof = async (password, salt, iterations,
                authMessage) => {
                const te = new TextEncoder();
                const saltedPassword = await this.calculatePbkdf2(te.encode(password), salt, iterations);
                const clientKey = await this.calculateHmac(saltedPassword, te.encode("Client Key"));
                const storedKey = await this.calculateSha256(clientKey);
                const clientSignature = await this.calculateHmac(storedKey, authMessage);
                const clientProof = this.calculateXor(clientSignature, clientKey);

                return clientProof;
            };
        }

        class MrsBaseApp extends Component {
            constructor(appName, stateParams) {
                super();

                // Initialize the App Component's state variables
                appName ??= "";
                stateParams ??= {};

                this.state = {
                    authenticating: false,
                    restarting: false,
                    ...stateParams,
                };


                // Ensure to force a render update to reflect URL hash changes when the user clicks the back button
                globalThis.addEventListener("hashchange", () => {
                    this.forceUpdate();
                }, false);

                if (stateParams.service !== undefined) {
                    this.session = new MrsBaseSession(stateParams.service, stateParams.authPath)

                    this.handleLogin(undefined, undefined, true);
                }
            }

            /**
             * Returns the current URL with a new URL search string
             *
             * @param searchString The new search string to use
             *
             * @returns The current URL with a new searchString
             */
            getUrlWithNewSearchString = (searchString = "") => {
                return globalThis.location.protocol + "//" + globalThis.location.host + globalThis.location.pathname +
                    (searchString !== "" ? `?${searchString}` : "") + globalThis.location.hash;
            };

            /**
             * Starts the login process using the given authApp
             *
             * @param authApp The name of the MRS auth_app
             */
            startLogin = (authApp) => {
                if (authApp !== undefined) {
                    // Encode current URL but replace the location.search with the authApp name
                    const redirectUrl = encodeURIComponent(MrsBaseApp.getUrlWithNewSearchString(`authApp=${authApp}`));

                    globalThis.location.href =
                        `${this.serviceUrl}/authentication/login?app=${authApp}&sessionType=bearer` +
                        `&onCompletionRedirect=${redirectUrl}`;
                } else {
                    globalThis.location.href = MrsBaseApp.getUrlWithNewSearchString();
                }
            };

            /**
             * Resets the page URL and the app state
             */
            logout = () => {
                globalThis.localStorage.removeItem(`${this.appName}JwtAccessToken`);
                globalThis.localStorage.removeItem(`${this.appName}AuthApp`);
                globalThis.localStorage.removeItem(`${this.appName}BuiltInAuth`);
                globalThis.history.pushState({}, document.title, globalThis.location.pathname);
                this.setState({ authenticating: false, error: undefined }, void this.afterLogout);
            };

            /**
             * Handles the login process
             *
             * @param authApp The authApp, if already know
             * @param accessToken The accessToken, if already given
             * @param mrsBuiltInAuth Set to true when the built in MRS Auth should be used
             */
            handleLogin = (authApp, accessToken, mrsBuiltInAuth = false) => {
                // Fetch URL parameters
                const urlParams = new URLSearchParams(globalThis.location.search);

                // If the authApp and accessToken have not been passed as parameters, check if they are given as URL parameters
                if (authApp === undefined) {
                    const authAppParam = urlParams.get("authApp");
                    authApp = authAppParam !== null ? authAppParam : undefined;
                }
                if (accessToken === undefined) {
                    const accessTokenParam = urlParams.get("accessToken");
                    accessToken = accessTokenParam !== null ? accessTokenParam : undefined;
                }

                // If accessToken is not specified, check globalThis.localStorage
                if (accessToken === undefined) {
                    const storedJwtAccessToken = globalThis.localStorage.getItem(`${this.appName}JwtAccessToken`);
                    accessToken = storedJwtAccessToken !== null ? storedJwtAccessToken : undefined;
                } else {
                    // If it was specified, store it in the globalThis.localStorage
                    globalThis.localStorage.setItem(`${this.appName}JwtAccessToken`, accessToken);

                    // Clean Browser URL without reloading the page
                    globalThis.history.replaceState(undefined, "", this.getUrlWithNewSearchString());
                }

                // Store/restore authApp from globalThis.localStorage as well
                if (authApp === undefined) {
                    const storedMrsNotesAuthApp = globalThis.localStorage.getItem(`${this.appName}AuthApp`);
                    authApp = storedMrsNotesAuthApp !== null ? storedMrsNotesAuthApp : undefined;
                    const storedMrsBuiltInAuth = globalThis.localStorage.getItem(`${this.appName}BuiltInAuth`);
                    mrsBuiltInAuth = storedMrsBuiltInAuth !== null ? (storedMrsBuiltInAuth === "true") : false;
                } else {
                    globalThis.localStorage.setItem(`${this.appName}AuthApp`, authApp);
                    globalThis.localStorage.setItem(`${this.appName}BuiltInAuth`, String(mrsBuiltInAuth));
                }

                if (this.session && accessToken) {
                    this.session.accessToken = accessToken;
                    this.session.authApp = authApp;
                }

                // Initialize the App Component's state variables
                this.setState({
                    authenticating: this.session?.accessToken !== undefined && !mrsBuiltInAuth,
                }, () => {
                    // Check if the current accessToken is still valid
                    if (this.session?.accessToken !== undefined) {
                        void this.session.getAuthenticationStatus().then((status) => {
                            if (status?.status === "authorized") {
                                // Execute additional handling that is defined in derived app class
                                this.afterHandleLogin(status).catch(() => {
                                    this.logout();
                                });
                            } else {
                                // If not, go back to login page
                                this.logout();
                            }
                        });
                    }
                });
            };

            afterLogout = async () => { /** */ };
            afterHandleLogin = async (_status) => { /** */ };
        }


        /**
         * The ModalError Component renders an error message
         */
        class ModalError extends Component {
            render = ({ error, resetError, logout }) => {
                return error ? html`
                <div class="modal">
                <div class="error">
                    <p>${error.stack.replace(/accessToken=.*?[&:]/gm, "accessToken=X:")}</p>
                    <div class="errorButtons">
                    <button class="flatButton" onClick=${() => resetError()}>Close</button>
                    <button class="flatButton" onClick=${() => logout()}>Restart</button>
                    </div>
                </div>
                </div>` : "";
            };
        }


        /**
         * The MrsLogin Component renders the MRS login controls
         */
        class MrsLogin extends Component {
            constructor(props) {
                super(props);

                this.state = {
                    userName: "",
                    userNameVerified: false,
                    authApps: undefined,
                    error: undefined,
                    authApp: props.authApp,
                };
            }

            componentDidMount() {
                const { session } = this.props;

                session.getAuthApps().then((authApps) => {
                    this.setState({ authApps });
                }).catch((error) => {
                    this.showLoginError(error);
                });
            }

            setStateClassStyle = (id, className) => {
                const e = document.getElementById(id);

                // Remove unwanted styles
                if (className !== "active") { e?.classList.remove("active"); }
                if (className !== "loading") { e?.classList.remove("loading"); }

                // Added desired style
                if (className !== undefined) { e?.classList.add(className); }
            };

            userNameChange = (userName) => {
                this.setStateClassStyle("userNameBtn", userName !== "" ? "active" : undefined);

                this.setState({ userName, userNameVerified: false, password: undefined, loginError: undefined });
            };

            passwordChange = (password) => {
                this.setStateClassStyle("passwordBtn", password !== "" ? "active" : undefined);

                this.setState({ password });
            };

            showLoginError = (error) => {
                this.setStateClassStyle("userNameBtn");
                this.setStateClassStyle("passwordBtn");

                this.setState({ password: undefined, loginError: error }, () => {
                    const e = document.getElementById("userName");
                    e?.focus();
                    e?.select();
                });
            };

            verifyUserName = async (authApp) => {
                const { session } = this.props;
                const { userName } = this.state;

                this.setStateClassStyle("userNameBtn", "loading");
                try {
                    await session.verifyUserName(authApp, userName);

                    this.setState({
                        userNameVerified: true,
                    }, () => { document.getElementById("userPassword")?.focus(); });
                } finally {
                    this.setStateClassStyle("userNameBtn", userName !== "" ? "active" : undefined);
                }
            };

            verifyPassword = async () => {
                const { handleLogin, session } = this.props;
                const { password } = this.state;

                if (password !== undefined && password !== "") {
                    this.setStateClassStyle("passwordBtn", "loading");

                    const response = await session.verifyPassword(password);

                    if (response.errorCode !== null && response.errorCode !== undefined) {
                        this.showLoginError(response.errorMessage);
                    }

                    handleLogin(response.authApp, response.jwt, true);
                    this.setStateClassStyle("userNameBtn", password !== "" ? "active" : undefined);
                }
            };

            /**
             * The component's render function
             *
             * @param props The component's properties
             * @param state The component's state
             *
             * @returns The rendered ComponentChild
             */
            render = (props, state) => {
                const { userName, password, loginError, userNameVerified, authApps, authApp } = state;

                let requestedAuthApp;
                // If a specific authApp has been given, use that one
                if (authApp) {
                    requestedAuthApp = authApps?.find((app) => {
                        return app.name.toLowerCase() === authApp.toLowerCase();
                    });
                } else {
                    // If not specific authApp was specified, use the first MRS authApp
                    requestedAuthApp = authApps?.find((app) => {
                        return app.vendorId === "0x30000000000000000000000000000000";
                    });
                }

                if (authApps === undefined) {
                    if (loginError !== undefined) {
                        return html`<br />
                            <div className="mrsLoginError">
                                <p>${String(loginError)}</p>
                            </div>`;
                    }

                    return html`
                        <div className="mrsLogin">
                            <p>Loading ...</p>
                        </div>`;
                }

                if (authApps.length === 0) {
                    return html`
                        <br />
                        <div className="mrsLoginError">
                            <p>No Authentication Apps defined for this REST Service.</p>
                        </div>`;
                }

                if (authApp && !requestedAuthApp) {
                    return html`
                        <br />
                        <div className="mrsLoginError">
                            <p>Requested Authentication App ${authApp} not found on REST Service.</p>
                        </div>`
                }

                // Handle MRS authApps
                if (requestedAuthApp?.vendorId === "0x30000000000000000000000000000000") {
                    // If an MRS authApp has been defined, immediately show the login inputs
                    const LoginNextBtn = html`
                        <div id="userNameBtn" className="mrsLoginBtnNext"
                            onClick=${() => { void this.verifyUserName(requestedAuthApp.name); }}
                            onKeyPress=${() => { /** */ }} role="button" tabIndex={-1} />`;
                    const loginBtnHtml = html`
                            <div className="mrsLoginField">
                                <input type="text" id="userName" placeholder="User Name or Email" autoFocus
                                    value=${userName}
                                    onInput=${(e) => { this.userNameChange(e.target.value); }}
                                    onKeyPress=${(e) => {
                            if (e.keyCode === 13) {
                                void this.verifyUserName(requestedAuthApp.name);
                            }
                        }} />
                                ${!userNameVerified && LoginNextBtn}
                            </div>`;
                    const passwordBtnHtml = html`
                            <div className="mrsLoginField">
                                <input type="password" id="userPassword" placeholder="Password" value=${password}
                                    onInput=${(e) => { this.passwordChange(e.target.value); }}
                                    onKeyPress=${(e) => { if (e.keyCode === 13) { void this.verifyPassword(); } }} />
                                <div id="passwordBtn" className="mrsLoginBtnNext"
                                    onClick=${() => { void this.verifyPassword(); }}
                                    onKeyPress=${() => { /** */ }} role="button" tabIndex={-2} />
                            </div>`;

                    // Single MRS AuthApp configured
                    return html`
                        <div className="mrsLogin">
                            <p><br/><br/>Sign in with ${requestedAuthApp.name}</p>
                            <div className="mrsLoginFields">
                                ${loginBtnHtml}
                                ${userNameVerified && passwordBtnHtml}
                            </div>
                            ${loginError !== undefined &&
                        html`<div className="mrsLoginError"><p>${loginError}</p></div>`
                        }
                            <div className="mrsLoginSeparator" />
                        </div>`;
                }

                return html`
                    <div className="mrsLogin">
                        <p>Requested Authentication App ${authApp} not supported yet.</p>
                    </div>`;
            }
        }

        class App extends MrsBaseApp {

            constructor(props) {
                super("MrsLogin", props);
            }

            /**
             * Starts the login process using the given authApp
             *
             * @param authApp The name of the MRS auth_app
             */
            startLogin = async (authApp) => {
                const { serviceUrl, authPath, redirectUrl } = this.props;

                // Encode current URL but replace the location.search with the authApp name
                const fullRedirectUrl = encodeURIComponent(this.getUrlWithNewSearchString(
                    `authApp=${authApp}&redirectUrl=${redirectUrl}`));

                const loginPath = `${serviceUrl}${authPath}/login?app=${authApp}&sessionType=bearer` +
                    `&onCompletionRedirect=${fullRedirectUrl}`;

                window.location.href = loginPath;
            }

            /**
             * Displays the given page by setting the URL hash accordingly
             *
             * @param page The name of the page (without # prefix)
             * @param forcedUpdate Whether a render of the app should be triggered
             */
            showPage = (page, forcedUpdate = true) => {
                // Update the URL
                window.history.pushState(undefined, undefined, "#" + page);

                // Force a render update to reflect the changed URL hash
                if (forcedUpdate) {
                    this.forceUpdate();
                }
            }

            /**
             * Displays the given error by setting the error component state
             */
            showError = (error) => {
                this.setState({ error });
            }

            /**
             * The component's render function
             *
             * @param props The component's properties
             * @param state The component's state
             */
            render = ({ service, authApp }, { error, authenticating, restarting, loginComplete }) => {
                const page = window.location.hash;
                const errorHtml = restarting ? "" :
                    html`<${ModalError} error=${error} resetError=${this.showError} logout=${this.logout}/>`;
                const headerHtml = html`
                    <div class="welcomeLogo" />
                    <div class="welcomeText">
                        <h2>MySQL REST Service</h2>
                        <p>Welcome to the MySQL REST Service.</p>
                    </div>`;
                const footerHtml = html`
                    <div class="welcomeSpacer"></div>
                    <div class="footer">
                        Copyright (c) 2022, 2024, Oracle and/or its affiliates.
                    </div>
                `;

                if (authenticating) {
                    return html`${errorHtml}
                        <div class="page">
                            <div class="doCenter">
                                <p>Loading ...</p>
                            </div>
                        </div>`;
                }

                if (service && !loginComplete) {
                    return html`${errorHtml}${headerHtml}
                        <${MrsLogin} startLogin=${this.startLogin} handleLogin=${this.handleLogin}
                            session=${this.session} authApp=${authApp} />
                        ${footerHtml}`;
                }

                if (loginComplete) {
                    return html`${headerHtml}
                        <div class="welcomeText">
                            <p>Logged in successfully.</p>
                        </div>
                        ${footerHtml}`;
                }

                return html`${headerHtml}
                    <div class="welcomeText">
                        <p>Please use the MySQL Shell to configure your MySQL REST Service.</p>
                    </div>
                    <div class="welcomeLinks">
                        <a href="https://blogs.oracle.com/mysql/post/introducing-the-mysql-rest-service">Learn More ></a>
                        <a href="https://dev.mysql.com/doc/mysql-shell-gui/en/mysql-shell-vscode-rest-services.html">Browse Tutorials ></a>
                        <a href="https://dev.mysql.com/doc/mysql-shell-gui/en">Read Docs ></a>
                    </div>
                    ${footerHtml}`;
            }

            afterHandleLogin = async (_status) => {
                const { redirectUrl } = this.props;

                if (redirectUrl) {
                    window.location.href = redirectUrl;
                } else {
                    this.setState({ loginComplete: true });
                }
            };
        }

        // Fetch URL parameters
        const urlParams = new Proxy(new URLSearchParams(window.location.search), {
            get: (searchParams, prop) => searchParams.get(prop),
        });

        render(html`<${App} service=${urlParams.service} authPath=${urlParams.authPath} authApp=${urlParams.authApp}
            redirectUrl=${urlParams.redirectUrl}/>`, document.querySelector('#root'))
    </script>
</body>

</html>