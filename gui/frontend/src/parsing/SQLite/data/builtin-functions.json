{
    "acos": [
        "acos(expr)\n\nReturn the arccosine of X. The result is in radians.",
        "_**Built-In Arithmetic Function**_"
    ],
    "acosh": [
        "acosh(X)\n\nReturn the hyperbolic arccosine of X. The result is in radians.",
        "_**Built-In Arithmetic Function**_"
    ],
    "asin": [
        "asin(X) \n\nReturn the arcsine of X. The result is in radians.",
        "_**Built-In Arithmetic Function**_"
    ],
    "asinh": [
        "asinh(X) \n\nReturn the hyperbolic arcsine of X. The result is in radians.",
        "_**Built-In Arithmetic Function**_"
    ],
    "atan": [
        "atan(X) \n\nReturn the arctangent of X. The result is in radians.",
        "_**Built-In Arithmetic Function**_"
    ],
    "atan2": [
        "atan2(X,Y) \n\nReturn the arctangent of Y/X. The result is in radians. The result is placed into correct quadrant depending on the signs of X and Y.",
        "_**Built-In Arithmetic Function**_"
    ],
    "ceil": [
        "ceil(X) \n\nReturn the next larger representable integer values above X. For positive values of X, this routine rounds away from zero. For negative values of X, this routine rounds toward zero.",
        "_**Built-In Arithmetic Function**_"
    ],
    "ceiling": [
        "ceiling(X) \n\nReturn the next larger representable integer values above X. For positive values of X, this routine rounds away from zero. For negative values of X, this routine rounds toward zero.",
        "_**Built-In Arithmetic Function**_"
    ],
    "cos": [
        "cos(X) \n\nReturn the cosine of X. X is in radians.",
        "_**Built-In Arithmetic Function**_"
    ],
    "cosh": [
        "cosh(X) \n\nnReturn the hyperbolic cosine of X. X is in radians.",
        "_**Built-In Arithmetic Function**_"
    ],
    "degrees": [
        "degrees(X) \n\nConvert value X from radians into degrees.",
        "_**Built-In Arithmetic Function**_ "
    ],
    "exp": [
        "exp(X) \n\nCompute e (Euler's number, approximately 2.71828182845905) raised to the power X.",
        "_**Built-In Arithmetic Function**_"
    ],
    "floor": [
        "floor(X) \n\nReturn the next representable integer value that is less than X. For positive numbers, this function rounds toward zero but for negative numbers, this function rounds away from zero.",
        "_**Built-In Arithmetic Function**_ "
    ],
    "ln": [
        "ln(X) \n\nReturn the natural logarithm of X.",
        "_**Built-In Arithmetic Function**_"
    ],
    "log": [
        "log(X)\n\nReturn the base-10 logarithm for X. Or, for the two-argument version, return the base-B logarithm of X.\n\nCompatibility note: SQLite works like PostgreSQL in that the log() function computes a base-10 logarithm. Most other SQL database engines compute a natural logarithm for log(). In the two-argument version of log(B,X), the first argument is the base and the second argument is the operand. This is the same as in PostgreSQL and MySQL, but is reversed from SQL Server which uses the second argument as the base and the first argument as the operand.",
        "_**Built-In Arithmetic Function**_"
    ],
    "log10": [
        "log10(X) \n\nReturn the base-10 logarithm for X. Or, for the two-argument version, return the base-B logarithm of X.\n\nCompatibility note: SQLite works like PostgreSQL in that the log() function computes a base-10 logarithm. Most other SQL database engines compute a natural logarithm for log(). In the two-argument version of log(B,X), the first argument is the base and the second argument is the operand. This is the same as in PostgreSQL and MySQL, but is reversed from SQL Server which uses the second argument as the base and the first argument as the operand.",
        "_**Built-In Arithmetic Function**_"
    ],
    "log2": [
        "log2(X)\n\nReturn the logarithm base-2 for the number X.",
        "_**Built-In Arithmetic Function**_"
    ],
    "mod": [
        "mod(X,Y)\n\nReturn the remainder after dividing X by Y. This is similar to the '%' operator, except that it works for non-integer arguments.",
        "_**Built-In Arithmetic Function**_"
    ],
    "pi": [
        "pi()\n\nReturn an approximation for Ï€.",
        "_**Built-In Arithmetic Function**_"
    ],
    "pow": [
        "pow(X,Y)\n\nCompute X raised to Y-th power.",
        "_**Built-In Arithmetic Function**_"
    ],
    "power": [
        "power(X,Y)\n\nCompute X raised to Y-th power.",
        "_**Built-In Arithmetic Function**_"
    ],
    "radians": [
        "radians(X)\n\nConvert X from degrees into radians.",
        "_**Built-In Arithmetic Function**_"
    ],
    "sin": [
        "sin(X)\n\nReturn the sine of X. X is in radians.",
        "_**Built-In Arithmetic Function**_"
    ],
    "sinh": [
        "sinh(X)\n\nReturn the hyperbolic sine of X. X is in radians.",
        "_**Built-In Arithmetic Function**_"
    ],
    "sqrt": [
        "sqrt(X)\n\nReturn the square root of X. NULL is returned if X is negative.",
        "_**Built-In Arithmetic Function**_"
    ],
    "tan": [
        "tan(X)\n\nReturn the tangent of X. X is in radians.",
        "_**Built-In Arithmetic Function**_"
    ],
    "tanh": [
        "tanh(X)\n\nReturn the hyperbolic tangent of X. X is in radians.",
        "_**Built-In Arithmetic Function**_"
    ],
    "trunc": [
        "trunc(X)\n\nReturn the first representable integers on the line from X to 0.0. This is similar to ceiling(X) and floor(X) except that it always rounds toward zero.",
        "_**Built-In Arithmetic Function**_"
    ],
    "abs": [
        "abs\n\nThe abs(X) function returns the absolute value of the numeric argument X. Abs(X) returns NULL if X is NULL. Abs(X) returns 0.0 if X is a string or blob that cannot be converted to a numeric value. If X is the integer -9223372036854775808 then abs(X) throws an integer overflow error since there is no equivalent positive 64-bit two complement value.",
        "_**Built-In Scalar Function**_"
    ],
    "changes": [
        "changes()\n\nThe changes() function returns the number of database rows that were changed or inserted or deleted by the most recently completed INSERT, DELETE, or UPDATE statement, exclusive of statements in lower-level triggers. The changes() SQL function is a wrapper around the sqlite3_changes() C/C++ function and hence follows the same rules for counting changes.",
        "_**Built-In Scalar Function**_"
    ],
    "char": [
        "char(X1,X2,...,XN)\n\nThe char(X1,X2,...,XN) function returns a string composed of characters having the unicode code point values of integers X1 through XN, respectively.",
        "_**Built-In Scalar Function**_"
    ],
    "coalesce": [
        "coalesce(X,Y,...)\n\nThe coalesce() function returns a copy of its first non-NULL argument, or NULL if all arguments are NULL. Coalesce() must have at least 2 arguments.",
        "_**Built-In Scalar Function**_"
    ],
    "glob": [
        "glob(X,Y)\n\nThe glob(X,Y) function is equivalent to the expression `Y GLOB X`. Note that the X and Y arguments are reversed in the glob() function relative to the infix GLOB operator. Y is the string and X is the pattern. So, for example, the following expressions are equivalent:\n\t`name GLOB '*helium*'`\n\t`glob('*helium*',name)`\n\nIf the sqlite3_create_function() interface is used to override the glob(X,Y) function with an alternative implementation then the GLOB operator will invoke the alternative implementation.",
        "_**Built-In Scalar Function**_"
    ],
    "hex": [
        "hex(X)\n\nThe hex() function interprets its argument as a BLOB and returns a string which is the upper-case hexadecimal rendering of the content of that blob.\n\nIf the argument X in \"hex(X)\" is an integer or floating point number, then \"interprets its argument as a BLOB\" means that the binary number is first converted into a UTF8 text representation, then that text is interpreted as a BLOB. Hence, `hex(12345678)` renders as `3132333435363738` not the binary representation of the integer value `0000000000BC614E`.",
        "_**Built-In Scalar Function**_"
    ],
    "ifnull": [
        "ifnull(X,Y)\n\nThe ifnull() function returns a copy of its first non-NULL argument, or NULL if both arguments are NULL. Ifnull() must have exactly 2 arguments. The ifnull() function is equivalent to coalesce() with two arguments.",
        "_**Built-In Scalar Function**_"
    ],
    "iif": [
        "iif(X,Y,Z)\n\nThe iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise. The iif(X,Y,Z) function is logically equivalent to and generates the same byte code as the CASE expression `CASE WHEN X THEN Y ELSE Z END`.",
        "_**Built-In Scalar Function**_"
    ],
    "instr": [
        "instr(X,Y)\n\nThe instr(X,Y) function finds the first occurrence of string Y within string X and returns the number of prior characters plus 1, or 0 if Y is nowhere found within X. Or, if X and Y are both BLOBs, then instr(X,Y) returns one more than the number bytes prior to the first occurrence of Y, or 0 if Y does not occur anywhere within X. If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs then both are interpreted as strings. If either X or Y are NULL in instr(X,Y) then the result is NULL.",
        "_**Built-In Scalar Function**_"
    ],
    "last_insert_rowid": [
        "last_insert_rowid()\n\nThe last_insert_rowid() function returns the ROWID of the last row insert from the database connection which invoked the function. The last_insert_rowid() SQL function is a wrapper around the sqlite3_last_insert_rowid() C/C++ interface function.",
        "_**Built-In Scalar Function**_"
    ],
    "length": [
        "length(X)\n\nFor a string value X, the length(X) function returns the number of characters (not bytes) in X prior to the first NUL character. Since SQLite strings do not normally contain NUL characters, the length(X) function will usually return the total number of characters in the string X. For a blob value X, length(X) returns the number of bytes in the blob. If X is NULL then length(X) is NULL. If X is numeric then length(X) returns the length of a string representation of X.",
        "_**Built-In Scalar Function**_"
    ],
    "like": [
        "like(X,Y[,Z])\n\n",
        "The like() function is used to implement the `Y LIKE X [ESCAPE Z]` expression. If the optional ESCAPE clause is present, then the like() function is invoked with three arguments. Otherwise, it is invoked with two arguments only. Note that the X and Y parameters are reversed in the like() function relative to the infix LIKE operator. X is the pattern and Y is the string to match against that pattern. Hence, the following expressions are equivalent:\n`name LIKE '%neon%`\n`like('%neon%',name)`\n\nThe sqlite3_create_function() interface can be used to override the like() function and thereby change the operation of the LIKE operator. When overriding the like() function, it may be important to override both the two and three argument versions of the like() function. Otherwise, different code may be called to implement the LIKE operator depending on whether or not an ESCAPE clause was specified.",
        "_**Built-In Scalar Function**_"
    ],
    "likelihood": [
        "likelihood(X,Y)\n\nThe likelihood(X,Y) function returns argument X unchanged. The value Y in likelihood(X,Y) must be a floating point constant between 0.0 and 1.0, inclusive. The likelihood(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles during run-time (that is, during calls to sqlite3_step()). The purpose of the likelihood(X,Y) function is to provide a hint to the query planner that the argument X is a boolean that is true with a probability of approximately Y. The unlikely(X) function is short-hand for likelihood(X,0.0625). The likely(X) function is short-hand for likelihood(X,0.9375).",
        "_**Built-In Scalar Function**_"
    ],
    "likely": [
        "likely(X)\n\nThe likely(X) function returns the argument X unchanged. The likely(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles at run-time (that is, during calls to sqlite3_step()). The purpose of the likely(X) function is to provide a hint to the query planner that the argument X is a boolean value that is usually true. The likely(X) function is equivalent to likelihood(X,0.9375). See also: unlikely(X).",
        "_**Built-In Scalar Function**_"
    ],
    "load_extension": [
        "load_extension(X[,Y])\n\nThe load_extension(X,Y) function loads SQLite extensions out of the shared library file named X using the entry point Y. The result of load_extension() is always a NULL. If Y is omitted then the default entry point name is used. The load_extension() function raises an exception if the extension fails to load or initialize correctly.\n\nThe load_extension() function will fail if the extension attempts to modify or delete an SQL function or collating sequence. The extension can add new functions or collating sequences, but cannot modify or delete existing functions or collating sequences because those functions and/or collating sequences might be used elsewhere in the currently running SQL statement. To load an extension that changes or deletes functions or collating sequences, use the sqlite3_load_extension() C-language API.\n\nFor security reasons, extension loaded is turned off by default and must be enabled by a prior call to sqlite3_enable_load_extension().",
        "_**Built-In Scalar Function**_"
    ],
    "lower": [
        "lower(X)\n\nThe lower(X) function returns a copy of string X with all ASCII characters converted to lower case. The default built-in lower() function works for ASCII characters only. To do case conversions on non-ASCII characters, load the ICU extension.",
        "_**Built-In Scalar Function**_"
    ],
    "ltrim": [
        "ltrim(X[,Y])\n\nThe ltrim(X,Y) function returns a string formed by removing any and all characters that appear in Y from the left side of X. If the Y argument is omitted, ltrim(X) removes spaces from the left side of X.",
        "_**Built-In Scalar Function**_"
    ],
    "max": [
        "max(X)\n\nThe max() aggregate function returns the maximum value of all values in the group. The maximum value is the value that would be returned last in an ORDER BY on the same column. Aggregate max() returns NULL if and only if there are no non-NULL values in the group.",
        "max(X,Y,...)\n\nThe multi-argument max() function returns the argument with the maximum value, or return NULL if any argument is NULL. The multi-argument max() function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If none of the arguments to max() define a collating function, then the BINARY collating function is used. Note that max() is a simple function when it has 2 or more arguments but operates as an aggregate function if given only a single argument.",
        "_**Built-In Scalar Function**_"
    ],
    "min": [
        "min(X)\n\n\n\nThe min() aggregate function returns the minimum non-NULL value of all values in the group. The minimum value is the first non-NULL value that would appear in an ORDER BY of the column. Aggregate min() returns NULL if and only if there are no non-NULL values in the group. ",
        "min(X,Y,...)\n\n\n\nThe multi-argument min() function returns the argument with the minimum value. The multi-argument min() function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If none of the arguments to min() define a collating function, then the BINARY collating function is used. Note that min() is a simple function when it has 2 or more arguments but operates as an aggregate function if given only a single argument.",
        "_**Built-In Scalar Function**_"
    ],
    "nullif": [
        "nullif(X,Y)\n\nThe nullif(X,Y) function returns its first argument if the arguments are different and NULL if the arguments are the same. The nullif(X,Y) function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If neither argument to nullif() defines a collating function then the BINARY is used.",
        "_**Built-In Scalar Function**_"
    ],
    "printf": [
        "printf(FORMAT,...)\n\nThe printf(FORMAT,...) SQL function works like the sqlite3_mprintf() C-language function and the printf() function from the standard C library. The first argument is a format string that specifies how to construct the output string using values taken from subsequent arguments. If the FORMAT argument is missing or NULL then the result is NULL. The %n format is silently ignored and does not consume an argument. The %p format is an alias for %X. The %z format is interchangeable with %s. If there are too few arguments in the argument list, missing arguments are assumed to have a NULL value, which is translated into 0 or 0.0 for numeric formats or an empty string for %s. See the built-in printf() documentation for additional information.",
        "_**Built-In Scalar Function**_"
    ],
    "quote": [
        "quote(X)\n\nThe quote(X) function returns the text of an SQL literal which is the value of its argument suitable for inclusion into an SQL statement. Strings are surrounded by single-quotes with escapes on interior quotes as needed. BLOBs are encoded as hexadecimal literals. Strings with embedded NUL characters cannot be represented as string literals in SQL and hence the returned string literal is truncated prior to the first NUL.",
        "_**Built-In Scalar Function**_"
    ],
    "random": [
        "random()\n\nThe random() function returns a pseudo-random integer between -9223372036854775808 and +9223372036854775807.",
        "_**Built-In Scalar Function**_"
    ],
    "randomblob": [
        "randomblob(N)\n\nThe randomblob(N) function return an N-byte blob containing pseudo-random bytes. If N is less than 1 then a 1-byte random blob is returned.\n\nHint: applications can generate globally unique identifiers using this function together with hex() and/or lower() like this:\n`hex(randomblob(16))`\n`lower(hex(randomblob(16)))`",
        "_**Built-In Scalar Function**_"
    ],
    "replace": [
        "replace(X,Y,Z)\n\nThe replace(X,Y,Z) function returns a string formed by substituting string Z for every occurrence of string Y in string X. The BINARY collating sequence is used for comparisons. If Y is an empty string then return X unchanged. If Z is not initially a string, it is cast to a UTF-8 string prior to processing.",
        "_**Built-In Scalar Function**_"
    ],
    "round": [
        "round(X[,Y])\n\nThe round(X,Y) function returns a floating-point value X rounded to Y digits to the right of the decimal point. If the Y argument is omitted, it is assumed to be 0.",
        "_**Built-In Scalar Function**_"
    ],
    "rtrim": [
        "rtrim(X[,Y])\n\nThe rtrim(X,Y) function returns a string formed by removing any and all characters that appear in Y from the right side of X. If the Y argument is omitted, rtrim(X) removes spaces from the right side of X.",
        "_**Built-In Scalar Function**_"
    ],
    "soundex": [
        "soundex(X)\n\nThe soundex(X) function returns a string that is the soundex encoding of the string X. The string `?000` is returned if the argument is NULL or contains no ASCII alphabetic characters. This function is omitted from SQLite by default. It is only available if the SQLITE_SOUNDEX compile-time option is used when SQLite is built.",
        "_**Built-In Scalar Function**_"
    ],
    "sqlite_compileoption_get": [
        "sqlite_compileoption_get(N)\n\nThe sqlite_compileoption_get() SQL function is a wrapper around the sqlite3_compileoption_get() C/C++ function. This routine returns the N-th compile-time option used to build SQLite or NULL if N is out of range. See also the compile_options pragma.",
        "_**Built-In Scalar Function**_"
    ],
    "sqlite_compileoption_used": [
        "sqlite_compileoption_used(X)\n\nThe sqlite_compileoption_used() SQL function is a wrapper around the sqlite3_compileoption_used() C/C++ function. When the argument X to sqlite_compileoption_used(X) is a string which is the name of a compile-time option, this routine returns true (1) or false (0) depending on whether or not that option was used during the build.",
        "_**Built-In Scalar Function**_"
    ],
    "sqlite_offset": [
        "sqlite_offset(X)\n\nThe sqlite_offset(X) function returns the byte offset in the database file for the beginning of the record from which value would be read. If X is not a column in an ordinary table, then sqlite_offset(X) returns NULL. The value returned by sqlite_offset(X) might reference either the original table or an index, depending on the query. If the value X would normally be extracted from an index, the sqlite_offset(X) returns the offset to the corresponding index record. If the value X would be extracted from the original table, then sqlite_offset(X) returns the offset to the table record.\n\nThe sqlite_offset(X) SQL function is only available if SQLite is built using the -DSQLITE_ENABLE_OFFSET_SQL_FUNC compile-time option.",
        "_**Built-In Scalar Function**_"
    ],
    "sqlite_source_id": [
        "sqlite_source_id()\n\nThe sqlite_source_id() function returns a string that identifies the specific version of the source code that was used to build the SQLite library. The string returned by sqlite_source_id() is the date and time that the source code was checked in followed by the SHA1 hash for that check-in. This function is an SQL wrapper around the sqlite3_sourceid() C interface.",
        "_**Built-In Scalar Function**_"
    ],
    "sqlite_version": [
        "sqlite_version()\n\nThe sqlite_version() function returns the version string for the SQLite library that is running. This function is an SQL wrapper around the sqlite3_libversion() C-interface.",
        "_**Built-In Scalar Function**_"
    ],
    "substr": [
        "substr(X,Y[,Z])\n\nThe substr(X,Y,Z) function returns a substring of input string X that begins with the Y-th character and which is Z characters long. If Z is omitted then substr(X,Y) returns all characters through the end of the string X beginning with the Y-th. The left-most character of X is number 1. If Y is negative then the first character of the substring is found by counting from the right rather than the left. If Z is negative then the abs(Z) characters preceding the Y-th character are returned. If X is a string then characters indices refer to actual UTF-8 characters. If X is a BLOB then the indices refer to bytes.\n\n`substring()` is an alias for `substr()` beginning with SQLite version 3.34.",
        "_**Built-In Scalar Function**_"
    ],
    "substring": [
        "substr(X,Y[,Z])\n\nThe substr(X,Y,Z) function returns a substring of input string X that begins with the Y-th character and which is Z characters long. If Z is omitted then substr(X,Y) returns all characters through the end of the string X beginning with the Y-th. The left-most character of X is number 1. If Y is negative then the first character of the substring is found by counting from the right rather than the left. If Z is negative then the abs(Z) characters preceding the Y-th character are returned. If X is a string then characters indices refer to actual UTF-8 characters. If X is a BLOB then the indices refer to bytes.\n\n`substring()` is an alias for `substr()` beginning with SQLite version 3.34.",
        "_**Built-In Scalar Function**_"
    ],
    "total_changes": [
        "total_changes()\n\nThe total_changes() function returns the number of row changes caused by INSERT, UPDATE or DELETE statements since the current database connection was opened. This function is a wrapper around the sqlite3_total_changes() C/C++ interface.",
        "_**Built-In Scalar Function**_"
    ],
    "trim": [
        "trim(X[,Y])\n\nThe trim(X,Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.",
        "_**Built-In Scalar Function**_"
    ],
    "typeof": [
        "typeof(X)\n\nThe typeof(X) function returns a string that indicates the datatype of the expression X: `null`, `integer`, `real`, `text`, or `blob`.",
        "_**Built-In Scalar Function**_"
    ],
    "unicode": [
        "unicode(X)\n\nThe unicode(X) function returns the numeric unicode code point corresponding to the first character of the string X. If the argument to unicode(X) is not a string then the result is undefined.",
        "_**Built-In Scalar Function**_"
    ],
    "unlikely": [
        "unlikely(X)\n\nThe unlikely(X) function returns the argument X unchanged. The unlikely(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles at run-time (that is, during calls to sqlite3_step()). The purpose of the unlikely(X) function is to provide a hint to the query planner that the argument X is a boolean value that is usually not true. The unlikely(X) function is equivalent to likelihood(X, 0.0625).",
        "_**Built-In Scalar Function**_"
    ],
    "upper": [
        "upper(X)\n\nThe upper(X) function returns a copy of input string X in which all lower-case ASCII characters are converted to their upper-case equivalent.",
        "_**Built-In Scalar Function**_"
    ],
    "zeroblob": [
        "zeroblob(N)\n\nThe zeroblob(N) function returns a BLOB consisting of N bytes of 0x00. SQLite manages these zeroblobs very efficiently. Zeroblobs can be used to reserve space for a BLOB that is later written using incremental BLOB I/O. This SQL function is implemented using the sqlite3_result_zeroblob() routine from the C/C++ interface.",
        "_**Built-In Scalar Function**_"
    ],
    "avg": [
        "avg(X)\n\nThe avg() function returns the average value of all non-NULL X within a group. String and BLOB values that do not look like numbers are interpreted as 0. The result of avg() is always a floating point value as long as at there is at least one non-NULL input even if all inputs are integers. The result of avg() is NULL if and only if there are no non-NULL inputs.",
        "_**Built-In Aggregate Function**_"
    ],
    "count": [
        "count(X)\n\n_The count(X) function returns a count of the number of times that X is not NULL in a group.",
        "count(*)\n\n_The count(*) function (with no arguments) returns the total number of rows in the group.",
        "_**Built-In Aggregate Function**_"
    ],
    "group_concat": [
        "group_concat(X[,Y])\n\nThe group_concat() function returns a string which is the concatenation of all non-NULL values of X. If parameter Y is present then it is used as the separator between instances of X. A comma is used as the separator if Y is omitted. The order of the concatenated elements is arbitrary.",
        "_**Built-In Aggregate Function**_"
    ],
    "sum": [
        "sum(X)\n\nThe sum() and total() aggregate functions return sum of all non-NULL values in the group. If there are no non-NULL input rows then sum() returns NULL but total() returns 0.0. NULL is not normally a helpful result for the sum of no rows but the SQL standard requires it and most other SQL database engines implement sum() that way so SQLite does it in the same way in order to be compatible. The non-standard total() function is provided as a convenient way to work around this design problem in the SQL language.\n\nThe result of total() is always a floating point value. The result of sum() is an integer value if all non-NULL inputs are integers. If any input to sum() is neither an integer or a NULL then sum() returns a floating point value which might be an approximation to the true sum.\n\nSum() will throw an \"integer overflow\" exception if all inputs are integers or NULL and an integer overflow occurs at any point during the computation. Total() never throws an integer overflow.",
        "_**Built-In Aggregate Function**_"
    ],
    "total": [
        "total(X)\n\nThe sum() and total() aggregate functions return sum of all non-NULL values in the group. If there are no non-NULL input rows then sum() returns NULL but total() returns 0.0. NULL is not normally a helpful result for the sum of no rows but the SQL standard requires it and most other SQL database engines implement sum() that way so SQLite does it in the same way in order to be compatible. The non-standard total() function is provided as a convenient way to work around this design problem in the SQL language.\n\nThe result of total() is always a floating point value. The result of sum() is an integer value if all non-NULL inputs are integers. If any input to sum() is neither an integer or a NULL then sum() returns a floating point value which might be an approximation to the true sum.\n\nSum() will throw an \"integer overflow\" exception if all inputs are integers or NULL and an integer overflow occurs at any point during the computation. Total() never throws an integer overflow.",
        "_**Built-In Aggregate Function**_"
    ],
    "row_number": [
        "row_number()\n\nThe number of the row within the current partition. Rows are numbered starting from 1 in the order defined by the ORDER BY clause in the window definition, or in arbitrary order otherwise. ",
        "_**Built-In Window Function**_"
    ],
    "rank": [
        "rank()\n\nThe row_number() of the first peer in each group - the rank of the current row with gaps. If there is no ORDER BY clause, then all rows are considered peers and this function always returns 1.",
        "_**Built-In Window Function**_"
    ],
    "dense_rank": [
        "dense_rank()\n\nThe number of the current row's peer group within its partition - the rank of the current row without gaps. Partitions are numbered starting from 1 in the order defined by the ORDER BY clause in the window definition. If there is no ORDER BY clause, then all rows are considered peers and this function always returns 1.",
        "_**Built-In Window Function**_"
    ],
    "percent_rank": [
        "percent_rank()\n\nDespite the name, this function always returns a value between 0.0 and 1.0 equal to (rank - 1)/(partition-rows - 1), where rank is the value returned by built-in window function rank() and partition-rows is the total number of rows in the partition. If the partition contains only one row, this function returns 0.0.",
        "_**Built-In Window Function**_"
    ],
    "cume_dist": [
        "cume_dist()\n\nThe cumulative distribution. Calculated as row-number/partition-rows, where row-number is the value returned by row_number() for the last peer in the group and partition-rows the number of rows in the partition.",
        "_**Built-In Window Function**_"
    ],
    "ntile": [
        "ntile(N)\n\nArgument N is handled as an integer. This function divides the partition into N groups as evenly as possible and assigns an integer between 1 and N to each group, in the order defined by the ORDER BY clause, or in arbitrary order otherwise. If necessary, larger groups occur first. This function returns the integer value assigned to the group that the current row is a part of.",
        "_**Built-In Window Function**_"
    ],
    "lag": [
        "lag(expr[, offset[, default]])\n\nThe first form of the lag() function returns the result of evaluating expression expr against the previous row in the partition. Or, if there is no previous row (because the current row is the first), NULL.\n\nIf the offset argument is provided, then it must be a non-negative integer. In this case the value returned is the result of evaluating expr against the row offset rows before the current row within the partition. If offset is 0, then expr is evaluated against the current row. If there is no row offset rows before the current row, NULL is returned.\n\nIf default is also provided, then it is returned instead of NULL if the row identified by offset does not exist.",
        "_**Built-In Window Function**_"
    ],
    "lead": [
        "lead(expr[, offset[, default]])\n\nThe first form of the lead() function returns the result of evaluating expression expr against the next row in the partition. Or, if there is no next row (because the current row is the last), NULL.\n\nIf the offset argument is provided, then it must be a non-negative integer. In this case the value returned is the result of evaluating expr against the row offset rows after the current row within the partition. If offset is 0, then expr is evaluated against the current row. If there is no row offset rows after the current row, NULL is returned.\n\nIf default is also provided, then it is returned instead of NULL if the row identified by offset does not exist.",
        "_**Built-In Window Function**_"
    ],
    "first_value": [
        "first_value(expr)\n\nThis built-in window function calculates the window frame for each row in the same way as an aggregate window function. It returns the value of expr evaluated against the first row in the window frame for each row.",
        "_**Built-In Window Function**_"
    ],
    "last_value": [
        "last_value(expr)\n\nThis built-in window function calculates the window frame for each row in the same way as an aggregate window function. It returns the value of expr evaluated against the last row in the window frame for each row.",
        "_**Built-In Window Function**_"
    ],
    "nth_value": [
        "nth_value(expr, N)\n\nThis built-in window function calculates the window frame for each row in the same way as an aggregate window function. It returns the value of expr evaluated against the row N of the window frame. Rows are numbered within the window frame starting from 1 in the order defined by the ORDER BY clause if one is present, or in arbitrary order otherwise. If there is no Nth row in the partition, then NULL is returned.",
        "_**Built-In Window Function**_"
    ],
    "date": [
        "date(time-value, modifier, modifier, ...)\n\nReturns the date in this format: `YYYY-MM-DD`",
        "_**Built-In Date/Time Function**_"
    ],
    "time": [
        "time(time-value, modifier, modifier, ...)\n\nReturns the time in this format: `HH:MM:SS`",
        "_**Built-In Date/Time Function**_"
    ],
    "datetime": [
        "datetime(time-value, modifier, modifier, ...)\n\nReturns date and time in this format: `YYYY-MM-DD HH:MM:SS`",
        "_**Built-In Date/Time Function**_"
    ],
    "julianday": [
        "julianday(time-value, modifier, modifier, ...)\n\nReturns the Julian day - the number of days since noon in Greenwich on November 24, 4714 B.C.",
        "_**Built-In Date/Time Function**_"
    ],
    "strftime": [
        "strftime(format, time-value, modifier, modifier, ...)\n\nReturns the date formatted according to the format string specified as the first argument. The format string supports the most common substitutions found in the `strftime()` function from the standard C library plus two new substitutions, %f and %J.",
        "_**Built-In Date/Time Function**_"
    ]
}
